<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx转发Https请求到Tomcat的实现]]></title>
    <url>%2FhelloBlog.github.io%2F2019%2F02%2F02%2F%E4%BD%BF%E7%94%A8Nginx%E8%BD%AC%E5%8F%91Https%E8%AF%B7%E6%B1%82%E5%88%B0Tomcat%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Nginx转发Https请求到Tomcat的实现Https现在大行其道，为了使老项目也兼容Https证书，同时考虑到80口的宝贵，故而使用nginx对特定项目路径进行转发，可以代理多个tomcat项目。 准备工作： 1.申请合法域名 2.申请对应该域名的证书，阿里云分为不同款，我这里使用的是nginx和tomcat款：-） 配置： 12345678910111213141516171819202122232425262728293031# nginx关键配置 # HTTPS server server &#123; listen 443; #我的服务域名 server_name www.little-black.net; ssl on; #对应的域名证书的路径(有相对路径和绝对路径的区分) ssl_certificate cert/1797474_little-black.net.pem; ssl_certificate_key cert/1797474_little-black.net.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; #被代理的项目地址 proxy_pass https://your project IP: PORT; index index.html index.htm index.jsp; #传递tomcat能识别的https请求 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; #放行静态资源 location ~ .*\.(html|htm|ico|png|jpg|jpeg|js|css|bmp)$ &#123; proxy_pass https://your project IP: PORT; &#125; &#125; 123456789101112131415#tomcat关键配置#配置tomcat证书&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot; keystoreFile=&quot;cert/1797474_little-black.net.pfx&quot;keystoreType=&quot;PKCS12&quot;keystorePass=&quot;0X0PIph9&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;#识别nginx转发的https的请求&lt;Engine defaultHost=&quot;localhost&quot; name=&quot;Catalina&quot;&gt;&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot;remoteIpHeader=&quot;X-Forwarded-For&quot; protocolHeader=&quot;X-Forwarded-Proto&quot;protocolHeaderHttpsValue=&quot;https&quot;/&gt;&lt;/Engine&gt; 以上。]]></content>
      <tags>
        <tag>Nginx Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript／Java实现阻塞线程的一个方法]]></title>
    <url>%2FhelloBlog.github.io%2F2019%2F01%2F06%2FJS%E5%92%8CJava%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript和Java实现阻塞线程的一个方法一：JavaScript 我们有时候会使用JavaScript开发跨平台的App，在某些特定场景下，我们希望在某个singleton量未达到预期时，多个线程中指定线程处于等待状态。当然我们也不能使用JavaScript的while死循环来解决问题，很显然，如果等待状态持续时间较长，死循环会在当前线程中调动cpu带来灾难性的性能开销。 于是，这里分享一个实现思路，使用ES6的语法和递归，可以让特定的多线程处于等待，同时只会产生极低的性能开销。 123456789101112131415161718192021wx.utils.await = async o=&gt;&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(async function () &#123; console.log('阻塞锁...............' + wx.userconfig.poll_lock); console.log('重复提交锁...............' + wx.userconfig.on_lock); if (wx.userconfig.poll_lock == false) &#123; resolve(wx.userconfig.poll_lock); return; &#125; // resolve(wx.userconfig.poll_lock); // return; let r = await wx.utils.await(o); if (wx.userconfig.poll_lock == false)&#123; resolve(wx.userconfig.poll_lock) return; &#125; &#125;, 1000); &#125;) &#125; 二：Java JDK中集成了相关自旋的方法，以使用很低的性能开销实现线程的等待，相关实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class ExeUtils &#123; private ExeUtils() &#123; &#125; private ExecutorService exe; private ExecutorService getExe() &#123; return exe; &#125; private ExeUtils setExe(ExecutorService exe) &#123; this.exe = exe; return this; &#125; public static void go(Runnable runnable) &#123; ExeUtils eu = new ExeUtils().setExe(Executors.newSingleThreadExecutor()); eu.getExe().submit(runnable); eu.shutdown(); &#125; public static void go(Callable&lt;Object&gt; callable) &#123; ExeUtils eu = new ExeUtils().setExe(Executors.newSingleThreadExecutor()); eu.getExe().submit(callable); eu.shutdown(); &#125; private void shutdown() &#123; try &#123; System.out.println("try to shut down【"+exe+"】"); exe.shutdown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(!exe.awaitTermination(10,TimeUnit.SECONDS))&#123; System.out.println("10秒检测器"); if(!exe.isTerminated())&#123; System.out.println("【"+exe+"】超时未关闭"); exe.shutdownNow(); System.out.println("【"+exe+"】被强制关闭"); &#125; &#125;else&#123; System.out.println("【"+exe+"】已被正确关闭啦"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); exe.shutdownNow(); &#125; &#125; &#125;&#125; 12345678910111213141516171819public Runnable testThread(Map testObj) &#123; Runnable r = () -&gt; &#123; System.out.println("异步线程原来的："+testObj.getString("is_work"));// JDO jdo = new JDO(); try &#123; Thread.sleep(5000); testObj.set("is_work","2"); System.out.println("异步线程set后的："+testObj.getString("is_work"));// jdo.update(testObj); &#125; catch (Exception e) &#123; e.printStackTrace();// jdo.rollbackAll(); &#125;finally &#123;// jdo.close(); &#125;// System.out.println("原来的："+testObj); &#125;; return r; &#125; 1234567891011121314151617public void testThreadMethod()&#123; ReentrantLock lock = new ReentrantLock(); try &#123; lock.lockInterruptibly(); Map t = new HashMap(); ExeUtils.go(testThread(t)); while (t.getString("is_work").equals("1"))&#123; lock.newCondition().await(); &#125; System.out.println(t.getString("is_work")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; 以上，新年快乐。]]></content>
      <tags>
        <tag>JavaScript Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple路由器-时间胶囊-跨平台使用的一点经验]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F07%2F22%2FApple%E8%B7%AF%E7%94%B1%E5%99%A8-%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E7%82%B9%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Apple路由器-时间胶囊-跨平台使用的一点经验目的：因个人需求，需要一个跨平台，稳定，高速，高容量的内网共享环境。 物料：Airport Time Capsule 、windows pc、macbook、AppleTV、ipad，1TB硬盘等 一般设置：按照手册设定路由器各项参数，将内置硬盘设定为mac生产工具的时光备份硬盘，网路上都有相关攻略。 特殊设置：也是难点，几乎未找到攻略。这里罗列几点，希望能给需要的人一点参考 tip1:目前为止，时光胶囊外接硬盘只识别fat32和nfs两种文件系统格式。所以外接硬盘格式化时需要注意。 tip2:不建议外接硬盘做分区。以免发生只识别一个区，另一个区被忽略的情况。 tip3:因为fat32不支持4g以上文件，所以建议用nfs格式的文件系统，因为windows不识别nfs文件系统，所以需要再做设置 tip4:为了访问nfs硬盘，因为win10系统支持nfs挂载，需要在程序服务里把对应的服务开启（网路上有攻略） tip5:win10需要安装最高版本的windows下的airport代理工具，apple官网有下载。win7版的亲测能用 tip6:安装完成后需要重启，右下角出现airport代理工具图标，说明安装成功。 tip7:windows下的文件可以直接粘贴复制到时间胶囊的外接硬盘中，无需自己做格式转换。 时间胶囊的5G信号非常稳定，apple全家桶互相访问无线速率100M/S也是正常。windows速率则大概10m／s不到，可能与我pc的年份比较久远有关。]]></content>
  </entry>
  <entry>
    <title><![CDATA[前后端Token通信的一点思路]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F06%2F15%2F%E5%89%8D%E5%90%8E%E7%AB%AFToken%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前后端Token通信的一点思路。 tip1:token后端应作合适的生命周期管理，并可以考虑和用户的身份标识绑定 tip2:token下发时，应当加入加密规则，预防下发参数被盗用后申请token。]]></content>
  </entry>
  <entry>
    <title><![CDATA[选择排序，插入排序，插入排序(移位)，冒泡排序，希尔排序（移位）的C++实现]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F05%2F06%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F(%E7%A7%BB%E4%BD%8D)%EF%BC%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%E7%A7%BB%E4%BD%8D)%E7%9A%84C%2B%2B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[选择排序，插入排序，插入排序(移位)，冒泡排序，希尔排序（移位）的C++实现及性能测试选择排序： 1234567891011121314151617181920212223242526272829/* * SelectionSort.h * * Created on: 2018年5月5日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_SELECTIONSORT_H_#define BASIC_SORT_INSERTION_SORT_SELECTIONSORT_H_template &lt;typename T&gt;void selectionSort(T arr[],int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; int minIndex = i; for (int j = i+1; j &lt; n; ++j) &#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; swap(arr[i],arr[minIndex]); &#125; return;&#125;#endif /* BASIC_SORT_INSERTION_SORT_SELECTIONSORT_H_ */ 插入排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /* * InsertionSort.h * * Created on: 2018年5月6日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_INSERTIONSORT_H_#define BASIC_SORT_INSERTION_SORT_INSERTIONSORT_H_template&lt;typename T&gt;void insertionSort(T arr[], int n) &#123; for (int i = 1; i &lt; n; ++i) &#123;// for(int j = i ; j&gt;0 ; --j)&#123;// if(arr[j]&lt;arr[j-1])&#123;// swap(arr[j-1],arr[j]);// &#125;else&#123;// break;// &#125;// &#125;// 写法2// for( int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )&#123;//// swap( arr[j] , arr[j-1] );// &#125;// // 写法3 T temp = arr[i]; int index;// for(index = i ; index&gt;0 &amp;&amp; arr[index-1] &gt; temp;--index)&#123;// arr[index] = arr[index-1];// &#125;////// arr[index] = temp; for (index = i; index &gt; 0; --index) &#123; if (arr[index - 1] &gt; temp) &#123; arr[index] = arr[index - 1]; &#125; else &#123; break; &#125; &#125; arr[index] = temp; &#125; return;&#125;#endif /* BASIC_SORT_INSERTION_SORT_INSERTIONSORT_H_ */ 冒泡排序 1234567891011121314151617181920212223/* * BubbleSort.h * * Created on: 2018年5月6日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_BUBBLESORT_H_#define BASIC_SORT_INSERTION_SORT_BUBBLESORT_H_template&lt;typename T&gt;void bubbleSort(T arr[], int n) &#123; for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr[j], arr[j + 1]); &#125; &#125; &#125;&#125;#endif /* BASIC_SORT_INSERTION_SORT_BUBBLESORT_H_ */ 希尔排序-移位 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * ShellSort.h * * Created on: 2018年5月6日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_SHELLSORT_H_#define BASIC_SORT_INSERTION_SORT_SHELLSORT_H_template&lt;typename T&gt;void shellSort(T arr[], int n)&#123; // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093... //取其序列的最大值，作为希尔排序的步进起始值 int h = 1; while( h &lt; n/3 ) &#123; h = 3 * h + 1; &#125; while( h &gt;= 1 )&#123; cout&lt;&lt;"希尔排序步进序列循环的值："&lt;&lt;h&lt;&lt;endl; // h-sort the array for( int i = h ; i &lt; n ; i ++ )&#123; T e = arr[i]; // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序 int j; for( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j =j- h )&#123; arr[j] = arr[j-h]; &#125; arr[j] = e; &#125; h = h/3; &#125;&#125;#endif /* BASIC_SORT_INSERTION_SORT_SHELLSORT_H_ */ 排序工具class.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* * SortUtils.h * * Created on: 2018年5月5日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_SORTUTILS_H_#define BASIC_SORT_INSERTION_SORT_SORTUTILS_H_#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;cassert&gt;using namespace std;namespace SortUtils&#123; int *arrayGenerator(int n,int left,int right)&#123;// assert(true); random_device rd; int *arr = new int[n]; for(int i=0;i&lt;n;++i)&#123; arr[i] = rd()%(right-left+1)+left; &#125; return arr; &#125; int *nearlyOrderArrayGenrator(int n,int swapTimes)&#123; random_device rd; int *arr = new int[n]; for(int i=0;i&lt;n;i++)&#123; arr[i] = i; &#125; for(int i=0;i&lt;swapTimes;++i)&#123; int posX = rd()%n; int posY = rd()%n; swap(arr[posX],arr[posY]); &#125; return arr; &#125; // 拷贝整型数组a中的所有元素到一个新的数组, 并返回新的数组 int *copyIntArray(int a[], int n)&#123; int *arr = new int[n]; //* 在VS中, copy函数被认为是不安全的, 请大家手动写一遍for循环:) copy(a, a+n, arr); return arr; &#125; template &lt;typename T&gt; void printArray(T arr[],int n)&#123; for(int i=0;i&lt;n;++i)&#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; template&lt;typename T&gt; bool isSort(T arr[],int n)&#123;// printArray(arr,n); for(int i=0;i&lt;n-1;++i)&#123; if(arr[i]&gt;arr[i+1])&#123; return false; &#125; &#125; return true; &#125; template&lt;typename T&gt; void testSort(string sortMethodName,void sortFunc(T[],int),T arr[],int n)&#123; clock_t start = clock(); sortFunc(arr,n); clock_t end = clock(); cout&lt;&lt;sortMethodName&lt;&lt;"==&gt;"&lt;&lt;double(end-start)/CLOCKS_PER_SEC&lt;&lt;" second"&lt;&lt;endl; assert(isSort(arr,n)); return; &#125;&#125;#endif /* BASIC_SORT_INSERTION_SORT_SORTUTILS_H_ */ 测试-主函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * InsertionSort.cpp * * Created on: 2018��5��5�� * Author: Will */#include &lt;iostream&gt;#include "SortUtils.h"#include "SelectionSort.h"#include "BubbleSort.h"#include "InsertionSort.h"#include "ShellSort.h"using namespace std;int main() &#123; int n = 20000; cout &lt;&lt; "随机数组长度为==》" &lt;&lt; n &lt;&lt; endl; int *arr1 = SortUtils::arrayGenerator(n, 0, n); int *arr2 = SortUtils::copyIntArray(arr1, n); int *arrBubble1 = SortUtils::copyIntArray(arr1, n); int *arrShell1 = SortUtils::copyIntArray(arr1, n);// SortUtils::printArray(arr1,n);// SortUtils::printArray(arr2,n); int *arr3 = SortUtils::arrayGenerator(n, 0, 5); int *arr4 = SortUtils::copyIntArray(arr3, n); int *arrBubble2 = SortUtils::copyIntArray(arr3, n); int *arrShell2 = SortUtils::copyIntArray(arr3, n); int swapTimes = 100; int *arr5 = SortUtils::nearlyOrderArrayGenrator(n, swapTimes); int *arr6 = SortUtils::copyIntArray(arr5, n); int *arrBubble3 = SortUtils::copyIntArray(arr5, n); int *arrShell3 = SortUtils::copyIntArray(arr5, n); SortUtils::testSort("random-选择排序", selectionSort, arr1, n); SortUtils::testSort("random-插入排序", insertionSort, arr2, n); SortUtils::testSort("random-冒泡排序",bubbleSort,arrBubble1,n); SortUtils::testSort("random-Shell排序",shellSort,arrShell1,n); cout&lt;&lt;endl; SortUtils::testSort("more order 选择排序", selectionSort, arr3, n); SortUtils::testSort("more order 插入排序", insertionSort, arr4, n); SortUtils::testSort("more order 冒泡排序", bubbleSort, arrBubble2, n); SortUtils::testSort("more order Shell排序", shellSort, arrShell2, n); cout&lt;&lt;endl; SortUtils::testSort("nearly order 选择排序", selectionSort, arr5, n); SortUtils::testSort("nearly order 插入排序", insertionSort, arr6, n); SortUtils::testSort("nearly order 冒泡排序", bubbleSort, arrBubble3, n); SortUtils::testSort("nearly order Shell排序", shellSort, arrShell3, n);// SortUtils::printArray(arr1,n);// SortUtils::printArray(arr2,n); delete[] arr1; delete[] arr2; delete[] arr3; delete[] arr4; delete[] arr5; delete[] arr6; delete[] arrShell1; delete[] arrShell2; delete[] arrShell3; delete[] arrBubble1; delete[] arrBubble2; delete[] arrBubble3;// cout &lt;&lt; endl; return 0;&#125; 测试结果 123456789101112131415161718192021222324252627282930313233343536373839404142随机数组长度为==》20000random-选择排序==&gt;1.098 secondrandom-插入排序==&gt;0.566 secondrandom-冒泡排序==&gt;3.749 second希尔排序步进序列循环的值：9841希尔排序步进序列循环的值：3280希尔排序步进序列循环的值：1093希尔排序步进序列循环的值：364希尔排序步进序列循环的值：121希尔排序步进序列循环的值：40希尔排序步进序列循环的值：13希尔排序步进序列循环的值：4希尔排序步进序列循环的值：1random-Shell排序==&gt;0.005 secondmore order 选择排序==&gt;1.227 secondmore order 插入排序==&gt;0.514 secondmore order 冒泡排序==&gt;2.727 second希尔排序步进序列循环的值：9841希尔排序步进序列循环的值：3280希尔排序步进序列循环的值：1093希尔排序步进序列循环的值：364希尔排序步进序列循环的值：121希尔排序步进序列循环的值：40希尔排序步进序列循环的值：13希尔排序步进序列循环的值：4希尔排序步进序列循环的值：1more order Shell排序==&gt;0.002 secondnearly order 选择排序==&gt;0.759 secondnearly order 插入排序==&gt;0.006 secondnearly order 冒泡排序==&gt;0.925 second希尔排序步进序列循环的值：9841希尔排序步进序列循环的值：3280希尔排序步进序列循环的值：1093希尔排序步进序列循环的值：364希尔排序步进序列循环的值：121希尔排序步进序列循环的值：40希尔排序步进序列循环的值：13希尔排序步进序列循环的值：4希尔排序步进序列循环的值：1nearly order Shell排序==&gt;0.003 second 总结： 选择排序：取得外循环的被选择的元素的下标，然后将该元素与右侧所有元素依次比较大小，如右侧元素小于取得下标的元素，则将下表赋值为较小元素的下标，直至到数列最后一个元素停止内层循环， 特点： 1.外循环被选中的元素的左侧的元素总是排好序的而且是最终所在的位置。 2.换位操作在外循环中实现，比插入排序在内层循环中换位性能要好。 3.对乱序，中度有序，接近有序的排序的耗时稳定在O($N^2$)级别 插入排序：取得外层循环中的元素，将其与其左侧元素做比较，如果左侧元素较大，则将当前元素与左侧元素换位。 特点： 1.当前元素的左侧元素总是有序的，因此，如果当前元素比其左侧元素大时，可以直接终止内层循环。这使得插入排序对接近有序的数列的排序耗时接近O(N)，也就是说插入排序在特定的，有序性较强的数列排序时比选择排序耗时更短。 2.换位操作发生在内层循环，换位耗时较长，因此衍生出改进型的插入排序：插入排序-移位 插入排序-移位：选择在内存里保存一份外层循环(外循环下标从1开始，即从第二个元素开始)的需要插入的元素（记为C）的副本（记为T），然后将该元素的副本T逐次地与其左侧元素做比较，如果左侧元素较大，则将左侧元素（记为L）与L右侧的元素移位（即L的位置空出，L+1的位置赋值成L，因为C的值已被复制成副本T，所以C的位置可以被其左侧的元素的值覆盖），直至没有元素比T大时，将空置的位置下标的元素赋值成T。 特点： 1.内层循环中由换位操作（开辟新内存，三次赋值操作）改良为赋值操作（移位操作），外层每次循环也仅有一次赋值操作。与选择排序相比，既保留了对接近有序数列排列耗时的优势，又在对无序数列排序时获得较好的性能优势。 2.仍然存在数列中的较小的值在数列右侧远端，需要逐次移位其左侧所有元素的操作。而希尔排序则为解决此类问题作出进一步的优化。 希尔排序：采用特定的数列作为步进数列，将待排序数列（记为arr）按照步进数列的每次取得的值（记为n）做切分。必须注意到，数列总能将下标按照n的步进切分成n个数列。于是，可以将arr按照被切分的数列，按照每次步进n进行插入排序（可以选用插入排序-移位做进一步的优化）。对同一步进的所有数列做插入排序，意味着，在程序上，就是从步进n开始到arr最右侧元素终止，做步进是n的插入排序操作。 特点： 1.采用步进数列，解决了arr数列右侧远端是较小值的逐次比较的问题，改良为按照步进大小进行n位移的大跨步的调整。 2.如果采用3n+1的步进数列，在arr数量级较小的情况下，相对归并，快速排序，代码实现起来较为简单，但能获得相近的性能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[与SSO对接，OA系统跨域免登录的一个设计思路与demo]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F04%2F25%2F%E4%B8%8ESSO%E5%AF%B9%E6%8E%A5%EF%BC%8COA%E7%B3%BB%E7%BB%9F%E8%B7%A8%E5%9F%9F%E5%85%8D%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E4%B8%8Edemo%2F</url>
    <content type="text"><![CDATA[与SSO对接，OA系统跨域免登录的一个设计思路与demoSSO与OA系统在不同的域，为优化用户体验和SSO服务器性能，希望用户在特定的条件下可以免登录 123456789101112131415161718192021222324252627Cookie sessionIdCookie = getCookieByName("oaSessionId"); if (sessionIdCookie != null) &#123; String historySessionId = sessionIdCookie.getValue(); if(StringUtils.isNotBlank(historySessionId))&#123; HttpSession historySession = SystemConstant.SESSION_MAP.get(historySessionId); if(historySession!=null)&#123; AuthorityInfo userInfoHistory = (AuthorityInfo) historySession.getAttribute("authorityInfo"); //如果userInfoHistory为null，可以考虑到持久化存储种再获取一次。 //现在这种写法受制于session的生命周期 //如果用户信息不为空，讲历史信息写入到当前session中，并返回管理页面 if(userInfoHistory != null)&#123; this._request.getSession().setAttribute("authorityInfo",userInfoHistory); //更新cookie的生命周期和历史sessiond的值 Cookie cookie = new Cookie("oaSessionId", this._request.getSession().getId()); cookie.setPath("/"); cookie.setMaxAge(60 * 60); ActionHandler.currentActionHandler()._response.addCookie(cookie); //更新全局sessionmap中的历史session信息 SystemConstant.SESSION_MAP.remove(historySessionId); SystemConstant.SESSION_MAP.put(this._request.getSession().getId(),this._request.getSession()); this._nextUrl = "/index.jsp";//自定义跳转jsp地址 return;//重定向返回 &#125; &#125; &#125; &#125; 设计思路如上，细节看代码，这里的this指代的是当前servlet，进而取得相应的req，res，一些自定义对象需要自己实现｡:.ﾟヽ(｡◕‿◕｡)ﾉﾟ.:｡+ﾟ。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注入多数据源并动态切换的一种方法]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F04%2F19%2FMybatis%E6%B3%A8%E5%85%A5%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Mybatis注入多数据源并动态切换的一种方法当我们需要分库分表分兼容多个mysql集群的时候，如果不使用相应的中间件，也可以使用spring自带的动态切换数据源的抽象类来达到这个目的。 step1：创建一个定义多数据源枚举待用 12345678910111213141516171819/** * Description: provide for mybatis-test-space. * * @author William.He * @version 1.0 * @since 2018/4/18 17:55 */public enum DBTypeEnum &#123; one("dataSource_one"), two("dataSource_two"); private String value; DBTypeEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; step2：创建一个线程安全的上下文类来获取step1中的枚举值 1234567891011121314151617181920212223242526272829303132333435/** * Description: provide for mybatis-test-space. * * @author William.He * @version 1.0 * @since 2018/4/18 17:56 */public class DbContextHolder &#123; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;(); /** * 设置数据源 * @param dbTypeEnum 数据源枚举 */ public static void setDbType(DBTypeEnum dbTypeEnum) &#123; contextHolder.set(dbTypeEnum.getValue()); &#125; /** * 取得当前数据源 * * @return 数据源枚举值，对应targetDataSources的key */ static String getDbType() &#123; return contextHolder.get(); &#125; /** * 清除上下文数据,即清空数据源 */ public static void clearDbType() &#123; contextHolder.remove(); &#125;&#125; step3：创建一个动态数据源继承自spring的动态数据源抽象类,并获取到相应的数据源枚举值 123456789101112131415161718/** * Description: provide for mybatis-test-space. * 动态切换数据源 * @author William.He * @version 1.0 * @since 2018/4/18 17:53 */public class DynamicDataSource extends AbstractRoutingDataSource &#123; /** * 取得当前使用哪个数据源 * @return datasource bean */ @Override protected Object determineCurrentLookupKey() &#123; return DbContextHolder.getDbType(); &#125;&#125; step4：将step3的动态数据源注入到mybatis初始化sqlSessionFactoryBean中，这里采用的是MP的注入方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Description: provide for mybatis-test-space. * * @author William.He * @version 1.0 * @since 2018/4/17 15:37 */@Configuration@MapperScan(basePackages = &#123;"com.pax.dal.dao"&#125;)//扫描接口public class MybatisPlusConfig &#123; @Resource(name = "dataSource") private DataSource dataSource; @Resource(name = "dataSource2") private DataSource dataSource2;// @Resource(name = "dynamicDataSource")// private DynamicDataSource dynamicDataSource; @Bean("mybatisSqlSession") public SqlSessionFactory sqlSessionFactory(DynamicDataSource dynamicDatasource, ResourceLoader resourceLoader, GlobalConfiguration globalConfiguration) throws Exception &#123; MybatisSqlSessionFactoryBean sqlSessionFactory = new MybatisSqlSessionFactoryBean(); sqlSessionFactory.setDataSource(dynamicDatasource);//Dynamic动态的 sqlSessionFactory.setTypeAliasesPackage("com.pax.dal.dao");//扫描model类 //获取自定义mapper文件的位置 sqlSessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath*:com.pax.dal.sqlMapper/*.xml")); MybatisConfiguration configuration = new MybatisConfiguration(); configuration.setDefaultScriptingLanguage(MybatisXMLLanguageDriver.class); configuration.setJdbcTypeForNull(JdbcType.NULL); sqlSessionFactory.setConfiguration(configuration); sqlSessionFactory.setPlugins(new Interceptor[]&#123;// new PaginationInterceptor(), //性能分析，慢查询报警 new PerformanceInterceptor(), //乐观锁 new OptimisticLockerInterceptor(), //分页插件，源生通用的 pageInterceptor() &#125;); sqlSessionFactory.setGlobalConfig(globalConfiguration); return sqlSessionFactory.getObject(); &#125; @Bean public GlobalConfiguration globalConfiguration() &#123; GlobalConfiguration conf = new GlobalConfiguration(new LogicSqlInjector()); conf.setLogicDeleteValue("-1"); conf.setLogicNotDeleteValue("1"); //全局主键默认类型，优先级次于@tableid注解 conf.setIdType(2); //下划线支持 conf.setDbColumnUnderline(true);// conf.setMetaObjectHandler(new H2MetaObjectHandler());//meta元 return conf; &#125; @Bean private DynamicDataSource dynamicDataSource()&#123; DynamicDataSource control = new DynamicDataSource(); control.setDefaultTargetDataSource(dataSource); Map&lt;Object,Object&gt; targetDataSources = new HashMap&lt;&gt;(); targetDataSources.put("dataSource_one",dataSource); targetDataSources.put("dataSource_two",dataSource2); control.setTargetDataSources(targetDataSources); return control; &#125; private PageInterceptor pageInterceptor() &#123; PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); properties.put("helperDialect", "mysql"); pageInterceptor.setProperties(properties); return pageInterceptor; &#125; step5：事务管理中的动态数据源同样使用step3创建的动态数据源注入 123456@Bean(name = "txManager") public DataSourceTransactionManager dataSourceTransactionManager(DynamicDataSource dynamicDatasource) &#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dynamicDatasource); return dataSourceTransactionManager; &#125; finally：配置的细节需要自己丰富，除此之外，就请愉快的使用吧， 使用 Demo： 123456789@Test public void testMysql()&#123; //切换数据源 DbContextHolder.setDbType(DBTypeEnum.one); //System.out.println(pax); //int i = pax.deleteByAutoId(7); List&lt;User&gt; users = pax.selectList(new EntityWrapper&lt;User&gt;()); System.out.println(users); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[传统singleton对象的正确打开方式๑乛◡乛๑]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F04%2F01%2F%E4%BC%A0%E7%BB%9Fsingleton%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%E0%B9%91%E4%B9%9B%E2%97%A1%E4%B9%9B%E0%B9%91%2F</url>
    <content type="text"><![CDATA[传统singleton对象的正确打开方式๑乛◡乛๑1234567891011121314151617/** * Description: provide for thirdpay-park-arena. * * @author William.He * @version 1.0 * @since 09/04/2018 12:00 PM */public class Singleton &#123; private Singleton() &#123;&#125; private static class PePeHolder&#123; private static Singleton singleton = new Singleton(); &#125; public static Singleton getInstance()&#123; return PePeHolder.singleton; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello blog]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F03%2F27%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[这是builder和template设计模式的一个demo。请ignore其中略过的细节。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import java.util.HashSet;import java.util.Iterator;import java.util.Random;import java.util.Set;/** * Description: provide for yearMeeting. * * @author William.He * @version 1.0 * @since 27/01/2018 10:02 AM */public abstract class YearMeeting &#123; public final void show(Set&lt;Emp&gt; emps, Song song) &#123; gatherTogether(emps); boolean empSinging = sing(emps, song); if (bossIsHappy(emps, empSinging)) &#123; getBossSunshine(emps); raisesGiven(); &#125; getBossSunshine(emps); goF__kYourself(); &#125; public abstract boolean sing(Set&lt;Emp&gt; emps, Song song); public abstract void goF__kYourself(); public void raisesGiven() &#123; throw new RuntimeException("everyone singing tomorrow is better than those oranges"); &#125; public boolean bossIsHappy(Set&lt;Emp&gt; emps, boolean bossSatisfied) &#123; Iterator&lt;Emp&gt; iterator = emps.iterator(); boolean isKneel = true; while (iterator.hasNext()) &#123; Emp emp = iterator.next(); isKneel = isKneel &amp;&amp; emp.isKneel(); &#125; return isKneel &amp;&amp; bossSatisfied &amp;&amp; (new Random().nextInt(100) &gt; 50); &#125; public abstract void getBossSunshine(Set&lt;Emp&gt; emps); public void BossRewardSomething(Emp emp) &#123; System.out.println("Boss reward " + emp.getName() + " someThing"); &#125; private void gatherTogether(Set&lt;Emp&gt; emps) &#123; if (emps == null) &#123; throw new RuntimeException("the big Qing is gone"); &#125; if (emps.size() &lt; 10) &#123; System.out.println("the coward is gone"); &#125; Iterator&lt;Emp&gt; iterator = emps.iterator(); while (iterator.hasNext()) &#123; Emp emp = iterator.next(); emp.checkIn(emp); &#125; &#125; public static void main(String[] args) &#123; Set&lt;Emp&gt; pzs = new HashSet&lt;&gt;(); Song song = new Song(); Emp emp = new Emp(); emp.show(pzs,song); &#125;&#125;class Emp extends YearMeeting &#123; private String name; private boolean kneel; private boolean stomachIssure; void checkIn(Emp emp) &#123; System.out.println(emp.getName() + " draw your big Name"); &#125; @Override public void getBossSunshine(Set&lt;Emp&gt; emps) &#123; System.out.println("Boss reward " + new Emp().getName() + " 200 TrafficCard"); &#125; @Override public void goF__kYourself() &#123; System.out.println("fill your f__king mouth and shut the f__k up"); &#125; @Override public boolean sing(Set&lt;Emp&gt; emps, Song song) &#123; Iterator&lt;Emp&gt; iterator = emps.iterator(); while (iterator.hasNext())&#123; Emp next = iterator.next(); if(song.isDisgusting())&#123; next.setStomachIssure(true); iterator.remove(); &#125; &#125; return emps.size()&gt;0; &#125; protected boolean isKneel() &#123; return this.kneel; &#125; protected String getName() &#123; return this.name; &#125; public boolean getStomachIssure() &#123; return false; &#125; public void setStomachIssure(boolean stomachIssure) &#123; this.stomachIssure = stomachIssure; &#125;&#125;class Song &#123; private String name; private boolean disgusting; protected String getName()&#123; return this.name; &#125; protected boolean isDisgusting()&#123; return this.disgusting; &#125;&#125;]]></content>
  </entry>
</search>
