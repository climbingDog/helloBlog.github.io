<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前后端Token通信的一点思路]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F06%2F15%2F%E5%89%8D%E5%90%8E%E7%AB%AFToken%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前后端Token通信的一点思路。 tip1:token后端应作合适的生命周期管理，并可以考虑和用户的身份标识绑定 tip2:token下发时，应当加入加密规则，预防下发参数被盗用后申请token。]]></content>
  </entry>
  <entry>
    <title><![CDATA[选择排序，插入排序，插入排序(移位)，冒泡排序，希尔排序（移位）的C++实现]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F05%2F06%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F(%E7%A7%BB%E4%BD%8D)%EF%BC%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%E7%A7%BB%E4%BD%8D)%E7%9A%84C%2B%2B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[选择排序，插入排序，插入排序(移位)，冒泡排序，希尔排序（移位）的C++实现及性能测试选择排序： 1234567891011121314151617181920212223242526272829/* * SelectionSort.h * * Created on: 2018年5月5日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_SELECTIONSORT_H_#define BASIC_SORT_INSERTION_SORT_SELECTIONSORT_H_template &lt;typename T&gt;void selectionSort(T arr[],int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; int minIndex = i; for (int j = i+1; j &lt; n; ++j) &#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; swap(arr[i],arr[minIndex]); &#125; return;&#125;#endif /* BASIC_SORT_INSERTION_SORT_SELECTIONSORT_H_ */ 插入排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /* * InsertionSort.h * * Created on: 2018年5月6日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_INSERTIONSORT_H_#define BASIC_SORT_INSERTION_SORT_INSERTIONSORT_H_template&lt;typename T&gt;void insertionSort(T arr[], int n) &#123; for (int i = 1; i &lt; n; ++i) &#123;// for(int j = i ; j&gt;0 ; --j)&#123;// if(arr[j]&lt;arr[j-1])&#123;// swap(arr[j-1],arr[j]);// &#125;else&#123;// break;// &#125;// &#125;// 写法2// for( int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )&#123;//// swap( arr[j] , arr[j-1] );// &#125;// // 写法3 T temp = arr[i]; int index;// for(index = i ; index&gt;0 &amp;&amp; arr[index-1] &gt; temp;--index)&#123;// arr[index] = arr[index-1];// &#125;////// arr[index] = temp; for (index = i; index &gt; 0; --index) &#123; if (arr[index - 1] &gt; temp) &#123; arr[index] = arr[index - 1]; &#125; else &#123; break; &#125; &#125; arr[index] = temp; &#125; return;&#125;#endif /* BASIC_SORT_INSERTION_SORT_INSERTIONSORT_H_ */ 冒泡排序 1234567891011121314151617181920212223/* * BubbleSort.h * * Created on: 2018年5月6日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_BUBBLESORT_H_#define BASIC_SORT_INSERTION_SORT_BUBBLESORT_H_template&lt;typename T&gt;void bubbleSort(T arr[], int n) &#123; for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr[j], arr[j + 1]); &#125; &#125; &#125;&#125;#endif /* BASIC_SORT_INSERTION_SORT_BUBBLESORT_H_ */ 希尔排序-移位 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * ShellSort.h * * Created on: 2018年5月6日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_SHELLSORT_H_#define BASIC_SORT_INSERTION_SORT_SHELLSORT_H_template&lt;typename T&gt;void shellSort(T arr[], int n)&#123; // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093... //取其序列的最大值，作为希尔排序的步进起始值 int h = 1; while( h &lt; n/3 ) &#123; h = 3 * h + 1; &#125; while( h &gt;= 1 )&#123; cout&lt;&lt;"希尔排序步进序列循环的值："&lt;&lt;h&lt;&lt;endl; // h-sort the array for( int i = h ; i &lt; n ; i ++ )&#123; T e = arr[i]; // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序 int j; for( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j =j- h )&#123; arr[j] = arr[j-h]; &#125; arr[j] = e; &#125; h = h/3; &#125;&#125;#endif /* BASIC_SORT_INSERTION_SORT_SHELLSORT_H_ */ 排序工具class.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* * SortUtils.h * * Created on: 2018年5月5日 * Author: Will */#ifndef BASIC_SORT_INSERTION_SORT_SORTUTILS_H_#define BASIC_SORT_INSERTION_SORT_SORTUTILS_H_#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;cassert&gt;using namespace std;namespace SortUtils&#123; int *arrayGenerator(int n,int left,int right)&#123;// assert(true); random_device rd; int *arr = new int[n]; for(int i=0;i&lt;n;++i)&#123; arr[i] = rd()%(right-left+1)+left; &#125; return arr; &#125; int *nearlyOrderArrayGenrator(int n,int swapTimes)&#123; random_device rd; int *arr = new int[n]; for(int i=0;i&lt;n;i++)&#123; arr[i] = i; &#125; for(int i=0;i&lt;swapTimes;++i)&#123; int posX = rd()%n; int posY = rd()%n; swap(arr[posX],arr[posY]); &#125; return arr; &#125; // 拷贝整型数组a中的所有元素到一个新的数组, 并返回新的数组 int *copyIntArray(int a[], int n)&#123; int *arr = new int[n]; //* 在VS中, copy函数被认为是不安全的, 请大家手动写一遍for循环:) copy(a, a+n, arr); return arr; &#125; template &lt;typename T&gt; void printArray(T arr[],int n)&#123; for(int i=0;i&lt;n;++i)&#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; template&lt;typename T&gt; bool isSort(T arr[],int n)&#123;// printArray(arr,n); for(int i=0;i&lt;n-1;++i)&#123; if(arr[i]&gt;arr[i+1])&#123; return false; &#125; &#125; return true; &#125; template&lt;typename T&gt; void testSort(string sortMethodName,void sortFunc(T[],int),T arr[],int n)&#123; clock_t start = clock(); sortFunc(arr,n); clock_t end = clock(); cout&lt;&lt;sortMethodName&lt;&lt;"==&gt;"&lt;&lt;double(end-start)/CLOCKS_PER_SEC&lt;&lt;" second"&lt;&lt;endl; assert(isSort(arr,n)); return; &#125;&#125;#endif /* BASIC_SORT_INSERTION_SORT_SORTUTILS_H_ */ 测试-主函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * InsertionSort.cpp * * Created on: 2018��5��5�� * Author: Will */#include &lt;iostream&gt;#include "SortUtils.h"#include "SelectionSort.h"#include "BubbleSort.h"#include "InsertionSort.h"#include "ShellSort.h"using namespace std;int main() &#123; int n = 20000; cout &lt;&lt; "随机数组长度为==》" &lt;&lt; n &lt;&lt; endl; int *arr1 = SortUtils::arrayGenerator(n, 0, n); int *arr2 = SortUtils::copyIntArray(arr1, n); int *arrBubble1 = SortUtils::copyIntArray(arr1, n); int *arrShell1 = SortUtils::copyIntArray(arr1, n);// SortUtils::printArray(arr1,n);// SortUtils::printArray(arr2,n); int *arr3 = SortUtils::arrayGenerator(n, 0, 5); int *arr4 = SortUtils::copyIntArray(arr3, n); int *arrBubble2 = SortUtils::copyIntArray(arr3, n); int *arrShell2 = SortUtils::copyIntArray(arr3, n); int swapTimes = 100; int *arr5 = SortUtils::nearlyOrderArrayGenrator(n, swapTimes); int *arr6 = SortUtils::copyIntArray(arr5, n); int *arrBubble3 = SortUtils::copyIntArray(arr5, n); int *arrShell3 = SortUtils::copyIntArray(arr5, n); SortUtils::testSort("random-选择排序", selectionSort, arr1, n); SortUtils::testSort("random-插入排序", insertionSort, arr2, n); SortUtils::testSort("random-冒泡排序",bubbleSort,arrBubble1,n); SortUtils::testSort("random-Shell排序",shellSort,arrShell1,n); cout&lt;&lt;endl; SortUtils::testSort("more order 选择排序", selectionSort, arr3, n); SortUtils::testSort("more order 插入排序", insertionSort, arr4, n); SortUtils::testSort("more order 冒泡排序", bubbleSort, arrBubble2, n); SortUtils::testSort("more order Shell排序", shellSort, arrShell2, n); cout&lt;&lt;endl; SortUtils::testSort("nearly order 选择排序", selectionSort, arr5, n); SortUtils::testSort("nearly order 插入排序", insertionSort, arr6, n); SortUtils::testSort("nearly order 冒泡排序", bubbleSort, arrBubble3, n); SortUtils::testSort("nearly order Shell排序", shellSort, arrShell3, n);// SortUtils::printArray(arr1,n);// SortUtils::printArray(arr2,n); delete[] arr1; delete[] arr2; delete[] arr3; delete[] arr4; delete[] arr5; delete[] arr6; delete[] arrShell1; delete[] arrShell2; delete[] arrShell3; delete[] arrBubble1; delete[] arrBubble2; delete[] arrBubble3;// cout &lt;&lt; endl; return 0;&#125; 测试结果 123456789101112131415161718192021222324252627282930313233343536373839404142随机数组长度为==》20000random-选择排序==&gt;1.098 secondrandom-插入排序==&gt;0.566 secondrandom-冒泡排序==&gt;3.749 second希尔排序步进序列循环的值：9841希尔排序步进序列循环的值：3280希尔排序步进序列循环的值：1093希尔排序步进序列循环的值：364希尔排序步进序列循环的值：121希尔排序步进序列循环的值：40希尔排序步进序列循环的值：13希尔排序步进序列循环的值：4希尔排序步进序列循环的值：1random-Shell排序==&gt;0.005 secondmore order 选择排序==&gt;1.227 secondmore order 插入排序==&gt;0.514 secondmore order 冒泡排序==&gt;2.727 second希尔排序步进序列循环的值：9841希尔排序步进序列循环的值：3280希尔排序步进序列循环的值：1093希尔排序步进序列循环的值：364希尔排序步进序列循环的值：121希尔排序步进序列循环的值：40希尔排序步进序列循环的值：13希尔排序步进序列循环的值：4希尔排序步进序列循环的值：1more order Shell排序==&gt;0.002 secondnearly order 选择排序==&gt;0.759 secondnearly order 插入排序==&gt;0.006 secondnearly order 冒泡排序==&gt;0.925 second希尔排序步进序列循环的值：9841希尔排序步进序列循环的值：3280希尔排序步进序列循环的值：1093希尔排序步进序列循环的值：364希尔排序步进序列循环的值：121希尔排序步进序列循环的值：40希尔排序步进序列循环的值：13希尔排序步进序列循环的值：4希尔排序步进序列循环的值：1nearly order Shell排序==&gt;0.003 second 总结： 选择排序：取得外循环的被选择的元素的下标，然后将该元素与右侧所有元素依次比较大小，如右侧元素小于取得下标的元素，则将下表赋值为较小元素的下标，直至到数列最后一个元素停止内层循环， 特点： 1.外循环被选中的元素的左侧的元素总是排好序的而且是最终所在的位置。 2.换位操作在外循环中实现，比插入排序在内层循环中换位性能要好。 3.对乱序，中度有序，接近有序的排序的耗时稳定在O($N^2$)级别 插入排序：取得外层循环中的元素，将其与其左侧元素做比较，如果左侧元素较大，则将当前元素与左侧元素换位。 特点： 1.当前元素的左侧元素总是有序的，因此，如果当前元素比其左侧元素大时，可以直接终止内层循环。这使得插入排序对接近有序的数列的排序耗时接近O(N)，也就是说插入排序在特定的，有序性较强的数列排序时比选择排序耗时更短。 2.换位操作发生在内层循环，换位耗时较长，因此衍生出改进型的插入排序：插入排序-移位 插入排序-移位：选择在内存里保存一份外层循环(外循环下标从1开始，即从第二个元素开始)的需要插入的元素（记为C）的副本（记为T），然后将该元素的副本T逐次地与其左侧元素做比较，如果左侧元素较大，则将左侧元素（记为L）与L右侧的元素移位（即L的位置空出，L+1的位置赋值成L，因为C的值已被复制成副本T，所以C的位置可以被其左侧的元素的值覆盖），直至没有元素比T大时，将空置的位置下标的元素赋值成T。 特点： 1.内层循环中由换位操作（开辟新内存，三次赋值操作）改良为赋值操作（移位操作），外层每次循环也仅有一次赋值操作。与选择排序相比，既保留了对接近有序数列排列耗时的优势，又在对无序数列排序时获得较好的性能优势。 2.仍然存在数列中的较小的值在数列右侧远端，需要逐次移位其左侧所有元素的操作。而希尔排序则为解决此类问题作出进一步的优化。 希尔排序：采用特定的数列作为步进数列，将待排序数列（记为arr）按照步进数列的每次取得的值（记为n）做切分。必须注意到，数列总能将下标按照n的步进切分成n个数列。于是，可以将arr按照被切分的数列，按照每次步进n进行插入排序（可以选用插入排序-移位做进一步的优化）。对同一步进的所有数列做插入排序，意味着，在程序上，就是从步进n开始到arr最右侧元素终止，做步进是n的插入排序操作。 特点： 1.采用步进数列，解决了arr数列右侧远端是较小值的逐次比较的问题，改良为按照步进大小进行n位移的大跨步的调整。 2.如果采用3n+1的步进数列，在arr数量级较小的情况下，相对归并，快速排序，代码实现起来较为简单，但能获得相近的性能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[与SSO对接，OA系统跨域免登录的一个设计思路与demo]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F04%2F25%2F%E4%B8%8ESSO%E5%AF%B9%E6%8E%A5%EF%BC%8COA%E7%B3%BB%E7%BB%9F%E8%B7%A8%E5%9F%9F%E5%85%8D%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E4%B8%8Edemo%2F</url>
    <content type="text"><![CDATA[与SSO对接，OA系统跨域免登录的一个设计思路与demoSSO与OA系统在不同的域，为优化用户体验和SSO服务器性能，希望用户在特定的条件下可以免登录 123456789101112131415161718192021222324252627Cookie sessionIdCookie = getCookieByName("oaSessionId"); if (sessionIdCookie != null) &#123; String historySessionId = sessionIdCookie.getValue(); if(StringUtils.isNotBlank(historySessionId))&#123; HttpSession historySession = SystemConstant.SESSION_MAP.get(historySessionId); if(historySession!=null)&#123; AuthorityInfo userInfoHistory = (AuthorityInfo) historySession.getAttribute("authorityInfo"); //如果userInfoHistory为null，可以考虑到持久化存储种再获取一次。 //现在这种写法受制于session的生命周期 //如果用户信息不为空，讲历史信息写入到当前session中，并返回管理页面 if(userInfoHistory != null)&#123; this._request.getSession().setAttribute("authorityInfo",userInfoHistory); //更新cookie的生命周期和历史sessiond的值 Cookie cookie = new Cookie("oaSessionId", this._request.getSession().getId()); cookie.setPath("/"); cookie.setMaxAge(60 * 60); ActionHandler.currentActionHandler()._response.addCookie(cookie); //更新全局sessionmap中的历史session信息 SystemConstant.SESSION_MAP.remove(historySessionId); SystemConstant.SESSION_MAP.put(this._request.getSession().getId(),this._request.getSession()); this._nextUrl = "/index.jsp";//自定义跳转jsp地址 return;//重定向返回 &#125; &#125; &#125; &#125; 设计思路如上，细节看代码，这里的this指代的是当前servlet，进而取得相应的req，res，一些自定义对象需要自己实现｡:.ﾟヽ(｡◕‿◕｡)ﾉﾟ.:｡+ﾟ。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注入多数据源并动态切换的一种方法]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F04%2F19%2FMybatis%E6%B3%A8%E5%85%A5%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Mybatis注入多数据源并动态切换的一种方法当我们需要分库分表分兼容多个mysql集群的时候，如果不使用相应的中间件，也可以使用spring自带的动态切换数据源的抽象类来达到这个目的。 step1：创建一个定义多数据源枚举待用 12345678910111213141516171819/** * Description: provide for mybatis-test-space. * * @author William.He * @version 1.0 * @since 2018/4/18 17:55 */public enum DBTypeEnum &#123; one("dataSource_one"), two("dataSource_two"); private String value; DBTypeEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; step2：创建一个线程安全的上下文类来获取step1中的枚举值 1234567891011121314151617181920212223242526272829303132333435/** * Description: provide for mybatis-test-space. * * @author William.He * @version 1.0 * @since 2018/4/18 17:56 */public class DbContextHolder &#123; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;(); /** * 设置数据源 * @param dbTypeEnum 数据源枚举 */ public static void setDbType(DBTypeEnum dbTypeEnum) &#123; contextHolder.set(dbTypeEnum.getValue()); &#125; /** * 取得当前数据源 * * @return 数据源枚举值，对应targetDataSources的key */ static String getDbType() &#123; return contextHolder.get(); &#125; /** * 清除上下文数据,即清空数据源 */ public static void clearDbType() &#123; contextHolder.remove(); &#125;&#125; step3：创建一个动态数据源继承自spring的动态数据源抽象类,并获取到相应的数据源枚举值 123456789101112131415161718/** * Description: provide for mybatis-test-space. * 动态切换数据源 * @author William.He * @version 1.0 * @since 2018/4/18 17:53 */public class DynamicDataSource extends AbstractRoutingDataSource &#123; /** * 取得当前使用哪个数据源 * @return datasource bean */ @Override protected Object determineCurrentLookupKey() &#123; return DbContextHolder.getDbType(); &#125;&#125; step4：将step3的动态数据源注入到mybatis初始化sqlSessionFactoryBean中，这里采用的是MP的注入方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Description: provide for mybatis-test-space. * * @author William.He * @version 1.0 * @since 2018/4/17 15:37 */@Configuration@MapperScan(basePackages = &#123;"com.pax.dal.dao"&#125;)//扫描接口public class MybatisPlusConfig &#123; @Resource(name = "dataSource") private DataSource dataSource; @Resource(name = "dataSource2") private DataSource dataSource2;// @Resource(name = "dynamicDataSource")// private DynamicDataSource dynamicDataSource; @Bean("mybatisSqlSession") public SqlSessionFactory sqlSessionFactory(DynamicDataSource dynamicDatasource, ResourceLoader resourceLoader, GlobalConfiguration globalConfiguration) throws Exception &#123; MybatisSqlSessionFactoryBean sqlSessionFactory = new MybatisSqlSessionFactoryBean(); sqlSessionFactory.setDataSource(dynamicDatasource);//Dynamic动态的 sqlSessionFactory.setTypeAliasesPackage("com.pax.dal.dao");//扫描model类 //获取自定义mapper文件的位置 sqlSessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath*:com.pax.dal.sqlMapper/*.xml")); MybatisConfiguration configuration = new MybatisConfiguration(); configuration.setDefaultScriptingLanguage(MybatisXMLLanguageDriver.class); configuration.setJdbcTypeForNull(JdbcType.NULL); sqlSessionFactory.setConfiguration(configuration); sqlSessionFactory.setPlugins(new Interceptor[]&#123;// new PaginationInterceptor(), //性能分析，慢查询报警 new PerformanceInterceptor(), //乐观锁 new OptimisticLockerInterceptor(), //分页插件，源生通用的 pageInterceptor() &#125;); sqlSessionFactory.setGlobalConfig(globalConfiguration); return sqlSessionFactory.getObject(); &#125; @Bean public GlobalConfiguration globalConfiguration() &#123; GlobalConfiguration conf = new GlobalConfiguration(new LogicSqlInjector()); conf.setLogicDeleteValue("-1"); conf.setLogicNotDeleteValue("1"); //全局主键默认类型，优先级次于@tableid注解 conf.setIdType(2); //下划线支持 conf.setDbColumnUnderline(true);// conf.setMetaObjectHandler(new H2MetaObjectHandler());//meta元 return conf; &#125; @Bean private DynamicDataSource dynamicDataSource()&#123; DynamicDataSource control = new DynamicDataSource(); control.setDefaultTargetDataSource(dataSource); Map&lt;Object,Object&gt; targetDataSources = new HashMap&lt;&gt;(); targetDataSources.put("dataSource_one",dataSource); targetDataSources.put("dataSource_two",dataSource2); control.setTargetDataSources(targetDataSources); return control; &#125; private PageInterceptor pageInterceptor() &#123; PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); properties.put("helperDialect", "mysql"); pageInterceptor.setProperties(properties); return pageInterceptor; &#125; step5：事务管理中的动态数据源同样使用step3创建的动态数据源注入 123456@Bean(name = "txManager") public DataSourceTransactionManager dataSourceTransactionManager(DynamicDataSource dynamicDatasource) &#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dynamicDatasource); return dataSourceTransactionManager; &#125; finally：配置的细节需要自己丰富，除此之外，就请愉快的使用吧， 使用 Demo： 123456789@Test public void testMysql()&#123; //切换数据源 DbContextHolder.setDbType(DBTypeEnum.one); //System.out.println(pax); //int i = pax.deleteByAutoId(7); List&lt;User&gt; users = pax.selectList(new EntityWrapper&lt;User&gt;()); System.out.println(users); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[传统singleton对象的正确打开方式๑乛◡乛๑]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F04%2F01%2F%E4%BC%A0%E7%BB%9Fsingleton%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%E0%B9%91%E4%B9%9B%E2%97%A1%E4%B9%9B%E0%B9%91%2F</url>
    <content type="text"><![CDATA[传统singleton对象的正确打开方式๑乛◡乛๑1234567891011121314151617/** * Description: provide for thirdpay-park-arena. * * @author William.He * @version 1.0 * @since 09/04/2018 12:00 PM */public class Singleton &#123; private Singleton() &#123;&#125; private static class PePeHolder&#123; private static Singleton singleton = new Singleton(); &#125; public static Singleton getInstance()&#123; return PePeHolder.singleton; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello blog]]></title>
    <url>%2FhelloBlog.github.io%2F2018%2F03%2F27%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[这是builder和template设计模式的一个demo。请ignore其中略过的细节。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import java.util.HashSet;import java.util.Iterator;import java.util.Random;import java.util.Set;/** * Description: provide for yearMeeting. * * @author William.He * @version 1.0 * @since 27/01/2018 10:02 AM */public abstract class YearMeeting &#123; public final void show(Set&lt;Emp&gt; emps, Song song) &#123; gatherTogether(emps); boolean empSinging = sing(emps, song); if (bossIsHappy(emps, empSinging)) &#123; getBossSunshine(emps); raisesGiven(); &#125; getBossSunshine(emps); goF__kYourself(); &#125; public abstract boolean sing(Set&lt;Emp&gt; emps, Song song); public abstract void goF__kYourself(); public void raisesGiven() &#123; throw new RuntimeException("everyone singing tomorrow is better than those oranges"); &#125; public boolean bossIsHappy(Set&lt;Emp&gt; emps, boolean bossSatisfied) &#123; Iterator&lt;Emp&gt; iterator = emps.iterator(); boolean isKneel = true; while (iterator.hasNext()) &#123; Emp emp = iterator.next(); isKneel = isKneel &amp;&amp; emp.isKneel(); &#125; return isKneel &amp;&amp; bossSatisfied &amp;&amp; (new Random().nextInt(100) &gt; 50); &#125; public abstract void getBossSunshine(Set&lt;Emp&gt; emps); public void BossRewardSomething(Emp emp) &#123; System.out.println("Boss reward " + emp.getName() + " someThing"); &#125; private void gatherTogether(Set&lt;Emp&gt; emps) &#123; if (emps == null) &#123; throw new RuntimeException("the big Qing is gone"); &#125; if (emps.size() &lt; 10) &#123; System.out.println("the coward is gone"); &#125; Iterator&lt;Emp&gt; iterator = emps.iterator(); while (iterator.hasNext()) &#123; Emp emp = iterator.next(); emp.checkIn(emp); &#125; &#125; public static void main(String[] args) &#123; Set&lt;Emp&gt; pzs = new HashSet&lt;&gt;(); Song song = new Song(); Emp emp = new Emp(); emp.show(pzs,song); &#125;&#125;class Emp extends YearMeeting &#123; private String name; private boolean kneel; private boolean stomachIssure; void checkIn(Emp emp) &#123; System.out.println(emp.getName() + " draw your big Name"); &#125; @Override public void getBossSunshine(Set&lt;Emp&gt; emps) &#123; System.out.println("Boss reward " + new Emp().getName() + " 200 TrafficCard"); &#125; @Override public void goF__kYourself() &#123; System.out.println("fill your f__king mouth and shut the f__k up"); &#125; @Override public boolean sing(Set&lt;Emp&gt; emps, Song song) &#123; Iterator&lt;Emp&gt; iterator = emps.iterator(); while (iterator.hasNext())&#123; Emp next = iterator.next(); if(song.isDisgusting())&#123; next.setStomachIssure(true); iterator.remove(); &#125; &#125; return emps.size()&gt;0; &#125; protected boolean isKneel() &#123; return this.kneel; &#125; protected String getName() &#123; return this.name; &#125; public boolean getStomachIssure() &#123; return false; &#125; public void setStomachIssure(boolean stomachIssure) &#123; this.stomachIssure = stomachIssure; &#125;&#125;class Song &#123; private String name; private boolean disgusting; protected String getName()&#123; return this.name; &#125; protected boolean isDisgusting()&#123; return this.disgusting; &#125;&#125;]]></content>
  </entry>
</search>
